package dal

import (
	"context"
	"time"

	"github.com/nortonlifelock/domain"
)

// Vulnerability implements the domain.Vulnerability interface and links to the VulnerabilityInfo table in the database
type Vulnerability struct {
	Conn domain.DatabaseConnection
	Info domain.VulnerabilityInfo
}

// ID returns the ID of the vulnerability as reported by the Aegis backend
func (vulnerability *Vulnerability) ID() string {
	return vulnerability.Info.ID()
}

// SourceID returns the ID of the vulnerability as reported by the vulnerability
func (vulnerability *Vulnerability) SourceID() string {
	return vulnerability.Info.SourceVulnID()
}

// Name returns a readable ID of the vulnerability
func (vulnerability *Vulnerability) Name() string {
	return vulnerability.Info.Title()
}

// Description returns a description of the vulnerability
func (vulnerability *Vulnerability) Description() string {
	return vulnerability.Info.Description()
}

func (vulnerability *Vulnerability) Threat() *string {
	return vulnerability.Info.Threat()
}

// CVSS2 returns the CVSS2 score of the vulnerability
func (vulnerability *Vulnerability) CVSS2() float32 {
	return vulnerability.Info.CVSSScore()
}

// CVSS3 returns the CVSS3 score of the vulnerability. A nil value is returned of a CVSS3 score was not provided by the vulnerability scanner
func (vulnerability *Vulnerability) CVSS3() *float32 {
	return vulnerability.Info.CVSS3Score()
}

// Updated returns the date that the vulnerability scanner last updated its information for this vulnerability
func (vulnerability *Vulnerability) Updated() time.Time {
	var updated time.Time
	if vulnerability.Info.Updated() != nil {
		updated = *vulnerability.Info.Updated()
	} else if vulnerability.Info.Created() != nil {
		updated = *vulnerability.Info.Created()
	}

	return updated
}

// Solutions returns a channel that contains all the solutions for the vulnerability
func (vulnerability *Vulnerability) Solutions(ctx context.Context) (<-chan domain.Solution, error) {
	out := make(chan domain.Solution)

	go func() {
		defer close(out)

		select {
		case <-ctx.Done():
			return
		case out <- &Solution{
			text: vulnerability.Info.Solution(),
		}:
		}

	}()

	return out, nil
}

// References returns a channel that contains all vulnerability references for the vulnerability
func (vulnerability *Vulnerability) References(ctx context.Context) (<-chan domain.VulnerabilityReference, error) {
	out := make(chan domain.VulnerabilityReference)

	go func() {
		defer close(out)

		references, err := vulnerability.Conn.GetVulnReferences(vulnerability.Info.SourceVulnID(), vulnerability.Info.SourceID())
		if err == nil {
			for _, reference := range references {
				select {
				case <-ctx.Done():
					return
				case out <- reference:
				}
			}
		}
	}()

	return out, nil
}

// Software returns the software that the vulnerability applies to
func (vulnerability *Vulnerability) Software() string {
	var software string
	if vulnerability.Info.Software() != nil {
		software = *vulnerability.Info.Software()
	}

	return software
}

// Patchable returns a Yes/No string dictating whether the vulnerability is patchable
// this is a pointer as Nexpose does not supply this information, so the column will be null for those vulns
// this is a string instead of a boolean because it's annoying to load boolean pointers from mySQL
func (vulnerability *Vulnerability) Patchable() *string {
	return vulnerability.Info.Patchable()
}

func (vulnerability *Vulnerability) Category() *string {
	return vulnerability.Info.Category()
}

// DetectionInformation returns additional information that applies to the vulnerability if provided
func (vulnerability *Vulnerability) DetectionInformation() string {
	var detectionInformation string
	if vulnerability.Info.DetectionInformation() != nil {
		detectionInformation = *vulnerability.Info.DetectionInformation()
	}

	return detectionInformation
}
